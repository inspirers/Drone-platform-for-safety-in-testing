---


---

<p>How the camera app works<br>
Changelog<br>
2024-02-28: Initial version<br>
2024-03-06: Refactoring of CameraController and CameraSurfaceTextureListener</p>
<p>When this guide was written, the app supported registring with the DJI SDK and showing a live camera feed.</p>
<h2 id="background">Background</h2>
<p>In order for the app to work at all and to connect to the drone, it must first be connected to the DJI SDK. This is done by registring the app using an SDK key generated on <a href="http://developer.dji.com">developer.dji.com</a>. We must then connect to the drone, find the camera feed and put it on display. This app is built on a modified version of the DJI SDK Android tutorials for <a href="https://developer.dji.com/document/9a028db0-fcbf-421b-bd6d-feadbc60a75d">registring an app</a> and <a href="https://developer.dji.com/document/06724d27-23cf-4741-b128-fc17d2891981">building a camera app</a>. However, the app has been modified as the Android standard has changed since those guides were published. What follows is a journey through the code which makes the app work. The code currently contains an RTMP livestream manager, but as this feature will not be used, it is not documented.</p>
<h2 id="registering-the-app">Registering the app</h2>
<p>As previously mentioned, the DJI SDK mandates that the app is registered with DJI before the app will function. To start, the DJI SDK must be loaded into the app. This is done by calling <code>Helper.install()</code> in the overridden <code>attachBaseContext</code> method of the <code>mApplication</code> class, as written in the DJI guide.</p>
<p>The actual registration process takes place in the <code>MainActivity</code> class. This activity was created by Android Studio as a template when the project was created. The <code>onCreate</code> method is called by Android when the activity is being created, i.e. when the app is starting. This method does two things. First, it calls <code>checkAndRequestPermissions()</code>, which will eventually register the app. Secondly, it does some navigation stuff to make the buttons reachable by code and enabling the navbar on the top of the screen.</p>
<h3 id="checkandrequestpermissions"><code>checkAndRequestPermissions()</code></h3>
<p>The task of this function is to go through all required permissions, stored in the list <code>REQUIRED_PERMISSION_LIST</code>. It will loop through this list and check if the permission is granted. Some permissions are granted as soon as they are declared in the file <code>AndroidManifest.xml</code>. Others need to be requested from the user. If this is required, this function will request the permission. If all permissions are acquired, the function calls <code>startSDKRegistration()</code>. If they aren’t, the app will show a toast and the user will need to grant the missing permissions in the Settings app.</p>
<h3 id="startsdkregistration"><code>startSDKRegistration()</code></h3>
<p>This function actually registers the app. This function is essentially provided by DJI. First, it checks that SDK registration isn’t being attempted somewhere else by <a href="https://en.wikipedia.org/wiki/Linearizability">atomically</a> checking if it already has been called. If this is not true, it will <a href="https://en.wikipedia.org/wiki/Asynchrony_%28computer_programming%29">asynchronically</a> execute the registration, which frees the app to continue rendering while the registration is in progress. This is important, as registration can take upwards of 10 seconds to complete.</p>
<p>The actual registration takes place through the method call <code>DJISDKManager.getInstance().registerApp()</code>.  This will take the app key specified in <code>AndroidManifest.xml</code> together with some other information, such as device ID and the bundle ID of the app. The function includes an anonymous <code>SDKManagerCallback</code>, which is an interface provided by DJI to handle registration and access to the drone. When the registration is complete, <code>onRegsiter()</code> is called. If the registration is successful, the app will attempt to connect to the drone by calling <code>DJISDKManager.getInstance().startConnectionToProduct()</code> and update the UI, see <code>notifyStatusChange()</code> below. If the registration fails, this is likely because of a bad internet connection.</p>
<h2 id="connecting-to-the-product">Connecting to the product</h2>
<p>This is handled essentially automatically by the SDK. There are four methods in total which are called by the SDK when there is some kind of status change. <code>onProductConnected()</code> is as the name implies called when the SDK has successfully connected to a drone. This method shows a toast and calls <code>notifyStatusChange()</code>. This behavior is repeated in <code>onProductDisconnected()</code>. Currently, there is a bug somewhere that causes the app to crash when the drone is disconnected.</p>
<p>There is also the method <code>onProductChanged()</code>, which currently does nothing and <code>onComponentChanged()</code>. This is called when a <em>component</em>, i.e. a camera or light is attached or removed from the drone. If the new component exists, it will also call <code>notifyStatusChange()</code>.</p>
<h3 id="notifystatuschange-and-updaterunnable"><code>notifyStatusChange()</code> and <code>updateRunnable</code></h3>
<p>The purpose of this is to broadcast the change to all listening receivers. The connected receiver is so far only in <code>FirstFragment</code>.</p>
<h3 id="firstfragment-class-and-updating-the-ui"><code>FirstFragment</code> class and updating the UI</h3>
<p>The purpose of the <code>FirstFragment</code> class is to handle the UI of the first fragment, which is the UI visible when you start the app.  When the fragment is created, the app will disable the button to view the feed and display a message to wait for app registration. When the app is registered, or when the product status changes, the app will receive a broadcast in the <code>BroadcastReciever reciever</code> and call the method <code>refreshSDK_UI()</code>.</p>
<h3 id="refreshsdk_ui"><code>refreshSDK_UI()</code></h3>
<p>This method sets the UI when there a change of status. It first checks if a product is connected by calling <code>DJISDKManager.getInstance().getProduct()</code>. If this returns <code>null</code>, there is no device connected and the UI displays an error message. If there is a connected device, the app enables the button and shows the device name connected.</p>
<h2 id="showing-the-camera-feed">Showing the camera feed</h2>
<p>When the user presses on the ‘Show Feed’-button in the app, the app switches to the second fragment. When the UI changes to this fragment, Android calls <code>onCreateView()</code>.  This sets the <code>SurfaceTextureListener</code> of the <code>TextureView</code>, which is the “surface” where the video appears, to an instance of <code>CameraSurfaceTextureListener</code>.  <code>onCreateView()</code> also creates a <code>VideoFeeder.VideoDataListener()</code> , which is responsible for receiving the raw video data from the drone and pass it on to the decoder to display it. Finally, it does some UI stuff which was auto-generated by Android Studio. The method <code>onResume()</code> is called whenever the fragment comes into view, both on start and when it is returned to. This method calls <code>initPreviewer()</code>.</p>
<h3 id="cameracontroller"><code>CameraController</code></h3>
<p>The <code>CameraController</code> is responsible for handling the access to the camera. It sets up the <code>recievedDataListener</code> and also holds the <code>initPreviewer()</code> method.</p>
<h3 id="initpreviewer-and-displaying-the-video"><code>initPreviewer()</code> and displaying the video</h3>
<p>When <code>initPreviewer()</code> is called, it starts of by checking the connection status. If no product is connected, it will display an error message. If a device is connected, it will again set the <code>SurfaceTextureListener</code> of the video surface to the instance of <code>CameraSurfaceTextureListener</code>, in case it got reassigned. If the aircraft model is known, checked by calling <code>product.getModel().equals(Model.UNKNOWN_AIRCRAFT))</code>, the previewer will tell the SDK to set the <code>VideoDataListener</code> to the one set in <code>onCreateView()</code>.</p>
<p>When the <code>SurfaceTexture</code> becomes available, i.e. ready for use, a <code>codecManager</code> is created which will take the data stream received by the <code>VideoDataListener</code> and push it onto the <code>SurfaceTexture</code>. This displays the video!</p>
<h3 id="updatevideosize"><code>updateVideoSize()</code></h3>
<p>By default, the <code>SurfaceTexture</code> will inflate to fit all available space. The problem is that this will mean the video will be stretched in some direction. This method fixes this by resizing the <code>SurfaceTexture</code> to have a 16:9 aspect ratio. It does this by calculating the current aspect ratio and comparing this to the desired 16:9 ratio. If the ratio is bigger, i.e. the video is too wide, the width will be reduced and if the ratio is smaller, i.e. the video is too tall, the height will be reduced. The new scaling is then applied to the <code>Transform</code> matrix of the <code>TextureView</code>.</p>

